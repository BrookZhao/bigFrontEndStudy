简答题
1. 说出下列代码的最终执行结果, 并解释为什么?
var a = [];
for (var i = 0;i < 10;i++) {
    a[i] = function () {
        console.log(i);
    }
}
a[6](); // 执行结果是10
最终的执行结果是10, 因为var声明的变量是没有块级作用域的, 相当于在与a变量同级的作用域中生命了变量i, 在循环结束之后, a数组中的每个元素都是一个函数, 函数的执行体是console.log(i) 这个i是函数外部作用域中的i, i的值在循环结束之后是10, 所以最终的执行结果就是10.

2. 说出下列代码的最终执行结果, 并解释为什么?
var tmp = 123;
if (true) {
    console.log(tmp);
    let tmp;
}
最终代码执行时, 会报错 'Cannot access 'tmp' before initialization', 因为let声明变量具有局部作用域, 并且不会声明提前, 试图在声明之前使用该变量时, 程序会报错, 在当前作用域的开始一直到let变量声明的这块区域被该变量的 '暂时性死区'.

3. 结合ES6新语法, 用最简单的方式找出数组中的最小值.
var arr = [12, 34, 32, 89, 4];
console.log(Math.min(...arr));

4. 请详细说明var, let, const三种声明变量的方式之间的具体差别.
var声明的变量没有块级作用域, let和const声明的变量具有块级作用域;
var声明的变量会产生声明提前的效果, let和const不会;
当在全局作用域中使用var声明变量时, 变量会作为全局变量(window)的属性, let和const不会;
let和const声明变量会具有暂时性死区, 在当前作用域的开始一直到let变量声明的这块区域被该变量的 '暂时性死区', var声明变量不会产生暂时性死区;
在同一作用域中可以用var声明同名变量, 后面声明的变量会覆盖前面声明的变量, 而let和const在同一作用域中不能声明同名变量, 会报错;
var和let声明的变量可以多次赋值, 并且在声明时可以先不赋值, 那么默认为undefined, const声明的变量时必须同时赋值, 并且在声明变量之后不能再次赋值.

5. 说出下列代码的最终执行结果, 并解释为什么?
var a = 10;
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a);
        });
    }
}
obj.fn(); // 20

最终的执行结果是20, 首先setTimeout中使用的是箭头函数, 箭头函数中的this指向在函数声明时就已经确定, 其指向就是箭头函数的外层作用域, 在本例中就是指向fn方法中的this, 再者方法(函数)中的this指向取决于其调用方式, 这里是作为对象的方法来调用的, 所以其中的this指向的就是调用它的对象, 也就是obj, 其应该输出obj.a, 也就是20.

6. 简述Symbol类型的用途.
Symbol函数会创建一个独一无二的变量, 并且Symbol类型的变量可以作为对象的属性, 所以其最主要的用途是为对象添加私有属性.

const name = Symbol('name');
const obj = {
    [name]: 'sss'
}

7. 说说什么是浅拷贝, 什么是深拷贝?
浅拷贝就是直接将对象的引用赋值给另外一个变量, 后面被赋值的变量和前面的变量引用相同的一块内存空间, 不论使用哪一个变量去操作, 都会使其他变量中的值发生变化;
深拷贝就是使用源对象创作出另外一个对象, 两个对象结构相同, 值也相同, 不占用同一块内存空间, 这样当改变一个时, 并不会对另外一个造成影响.

// 递归深拷贝
function deepCopy(origin, target = {}) {
    for (key in origin) {
        if (origin.hasOwnProperty(key)) {
            if (typeof origin[key] === 'object' && origin[key] !== null) {
                if (Object.prototype.toString.call(origin[key]) === '[object Array]') {
                    target[key] = [];
                } else {
                    target[key] = {};
                }
                deepCopy(origin[key], target[key]);
            } else {
                target[key] = origin[key];
            }
        }
    }
    return target;
}

8. 简述TypeScript与JavaScript之间的关系
TypeScript是JavaScript的一个超级, 也就是TypeScript语言在JavaScript的基础之上增加了一些新的特性, 包括类型检查系统, 和对ECMAScript新版本的支持等. 任何一种JavaScript运行环境下的引用程序都可以使用TypeScript来进行开发, 比如浏览器应用, node应用等. 在开发完成之后可以将TypeScript编写的代码转化为JavaScript代码运行在JavaScript的运行环境之下.

9. 谈谈TypeScript的优缺点
优点:
静态类型检查可以帮助开发人员方便的找到一些类型错误, 避免将此类错误带到测试以及生产阶段;
接口等规范的使用可以有效的提高开发人员之间的协作效率, 提高工作效率, 比如对于一个传入的对象, 可以使用接口规范其必须拥有的字段等;
有助于优化项目代码, 适合于大型项目使用;
相较于Flow, TypeScript作为一门语言, 不仅提供了静态类型检查的功能, 还提供了一些例如枚举, 抽象, 接口等功能, 方便开发过程中的应用, 而且其社区强大, 对微软自家开发工具的支持程度很好.
缺点:
相比较JavaScript, TypeScript语言自身增加了很多的概念, 比如枚举, 接口, 抽象, 泛型等, 增加了语言的学习成本;
会增加开发成本, 需要在项目初期编写对象或者函数的类型声明等.

10. 描述引用计数的工作原理和优缺点
通过一个引用计数器来维护当前对象的引用数, 当对象的引用数发生改变时, 引用计数器就开始工作, 判断当前对象的引用数是否为0, 如果为0就认为当前对象是一个垃圾对象, 此时JavaScript的垃圾回收机制立即开始工作, 将垃圾对象的内存空间进行回收于释放.

优点:

可以对垃圾对象立即进行回收, 引用计数器通过判断对象的引用数是否为0来判断对象是否为垃圾对象, 如果是垃圾对象就立即回收;
最大限度的减少程序的暂停, 因为引用计数器实时监测对象的引用数, 一旦发现垃圾对象就立即回收, 可以保证内存不被沾满, 减少暂停.
缺点:

无法回收循环引用的对象;
时间开销较大, 因为引用计数器需要时刻监控这对象的引用数量.

11. 描述标记整理算法的工作流程

标记整理算法实际上是对标记清除算法的增强:

首先标记算法会遍历内存中所有的对象, 并对可达对象进行标记;
标记完成之后再次遍历所有对象, 与标记清除不同的是, 标记整理会对未标记对象进行移位操作, 使其内存位置连续;
在以为完成之后将未标记对象进行清除, 这样就保证了释放出来的内存空间的连续, 方便后面的使用.

12. 描述V8中新生代存储区垃圾回收的流程
新生代存储区是用来存放新生代对象的, 新生代对象就是值, 存活时间比较短的对象, 比如函数作用域中的变量, 在函数执行结束之后就要被释放, 此类对象的存活时间比较短, 就是新生代对象.

回收的过程会采用复制算法和标记整理:

首先会将新生代存储区划分为二个等大的空间, 如使用空间From和空闲空间To;
在内存使用的过程中会先使用From空间, 引擎会将活动对象先存储于From空间;
在From空间使用到一定程度之后就会触发标记整理算法, 去标记From空间中的活动对象, 并将所有的活动对象拷贝至空闲空间To;
所以To空间已经存储了From区中的活动对象, 下一步就是将From空间释放, 完成新生代存储区的垃圾回收流程.

13. 描述增量标记算法在何时使用以及其工作原理

增量标记算法会在老生代存储区的垃圾回收过程中, 当变量较多, 标记算法无法在短时间内完成是使用, 其原理就是将原本一个时间较长的标记操作拆分成几个小的标记操作, 在小的标记操作中间程序依然可以运行, 这样就降低了GC算法对程序的阻塞影响, 提升了用户体验.